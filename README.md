# howtotakesnapbrave
======================== Global $aWebcamList[9] Global $aCompressorList[50] ;~ Global $aAuCompressorList[50] Global $aMicList[9] Global $iWebcam = 1, $iWebAudio = 0, $iWebRescale = 1, $iWebX, $iWebY, $iWebBpp, $aZoomPos[4] $aZoomPos[0] = 1 $aZoomPos[1] = 0 $aZoomPos[2] = 1 $aZoomPos[3] = 0  Global $oBasicAudio, $oBasicVideo, $oBuild, $oCapture[9], $oCaptureAudio, $oGraph, $oIBaseFilter, $oMediaControl, $oDevEnum, $oEnum, $oICreateDevEnum, $oIEnumMoniker Global $oVideoWindow, $oVmr9, $oCompressor, $oStreamConfig Global $Vmr9 = 1 ; ===============================================================================================================================  ; #CONSTANTS# =================================================================================================================== #include "DirectShow_Interfaces.au3" ; ===============================================================================================================================  ; #CURRENT# ===================================================================================================================== ;_WebcamDS_ReleaseObjects ;_WebcamDS_RenderWebcam ;_WebcamDS_SaveFile ;_WebcamDS_WebcamInit ; ===============================================================================================================================  ; #INTERNAL_USE_ONLY# =========================================================================================================== ;_WebcamDS_EnumerateDevices ;_WebcamDS_Reset ;_WebcamDS_SelectRect ; ===============================================================================================================================   ; #FUNCTION# ==================================================================================================================== ; ; Name...........: _WebcamDS_ReleaseObjects ; Description ...: release Objects created during script and at the end of it ; Syntax.........: _WebcamDS_ReleaseObjects($iArg = 0) ; Parameters ....: $iArg   - use 0 if you want to delete only the current capture obj, otherwise (ie: at the end) put it to 1 ; Return values .: Success - it deletes the objects created ;                  Failure - Returns 0 and Sets @Error: ;                  |0 - No error. ; Author ........: Frank10 ; Modified.......: ; Remarks .......: ; Related .......: ; Link ..........; ; Example .......; Yes ; ; =============================================================================================================================== Func _WebcamDS_ReleaseObjects($iArg = 0)     ;$oMediaControl.Stop()     $oMediaControl = 0     $oVmr9 = 0     $oCapture[$iWebcam] = 0     If $iArg Then $oCapture = 0     $oCaptureAudio = 0     $oBasicAudio = 0     $oBasicVideo = 0     $oVideoWindow = 0     $oGraph = 0     $oBuild = 0     $oCompressor = 0 EndFunc   ;==>_WebcamDS_ReleaseObjects    ; #FUNCTION# ==================================================================================================================== ; ; Name...........: _WebcamDS_RenderWebcam ; Description ...: call it to set which webcam to display, audio preview, resolution, scale to GUI, zoom ; Syntax.........: _WebcamDS_RenderWebcam($iNumberWebcam=1,$iAudioMic=0,$hGuiWin[,$iScale=1[,$xVideo=640[,$yVideo=480[,$ibpp=16[,$iZoomX=0[,$iZoomY=0[,$iZoomW=0[,$iZoomH=0]]]]]]]]) ; Parameters ....: $iNumberWebcam - The webcam to display (from 1) ;                  $iAudioMic   - If you want to preview the audio from the mic of the webcam set it to the corresponding ;                                   position of the mic ;                               - see the position in the Mic list in the array $aMicList filled by _WebcamInit (the position of ;                                   the Mic isn't always equal to the webcam position!) ;                               - it's possible to view one webcam and listen to the mic of another one! ;                               - if you don't want audio preview, set it to 0 ;                  $hGuiWin     - The GUI you create to display the webcam ;                  $iScale      - if you want to scale the webcam resolution to the res of the GUI, set it to 1, otherwise to 0 ;                  $xVideo      - The webcam Width ;                  $yVideo      - The webcam Height ;                  $ibpp        - bitplane (if you put strange values it doesn't seem to change it..) normal: 12-16-24 ;                  $iZoomX      - rectangle Zoom offsetX (0 = noZoom) ;                               - if you use it manually, be careful to put values that are inside the original width-height of ;                                   webcam otherwise it doesn't work ;                               - it's better to use the Setrect func drawing the rectangle with mouse directly on the GUI ;                  $iZoomY      - rectangle Zoom offsetY (0 = noZoom) ;                  $iZoomW      - rectangle Zoom Width (0 = noZoom) ;                  $iZoomH      - rectangle Zoom Heigth (0 = noZoom) ; Return values .: Success - it displays the webcam selected ;                  Failure - Returns 0 and Sets @Error: ;                  |0 - No error. ; Author ........: Frank10 ; Modified.......: ; Remarks .......: ; Related .......: ; Link ..........; ; Example .......; Yes ; ; =============================================================================================================================== ;~ Func _RenderWebcam(ByRef $iWebcam,$hGuiWin=$hGUI,ByRef $iScale,$xVideo='640',$yVideo='480',$ibpp='16',$iZoomX=0,$iZoomY=0,$iZoomW=0,$iZoomH=0) ;~ Func _RenderWebcam($iWebcam,$hGuiWin=$hGUI,$iScale,$xVideo='640',$yVideo='480',$ibpp='16',$iZoomX=0,$iZoomY=0,$iZoomW=0,$iZoomH=0) Func _WebcamDS_RenderWebcam($iNumberWebcam, $iAudioMic, $hGuiWin, $iScale = 1, $xVideo = 640, $yVideo = 480, $ibpp = 16, $iZoomX = 0, $iZoomY = 0, $iZoomW = 0, $iZoomH = 0)     Local $hr     $iWebcam = $iNumberWebcam     $iWebAudio = $iAudioMic     $iWebRescale = $iScale     $iWebX = $xVideo     $iWebY = $yVideo      _WebcamDS_EnumerateDevices($sCLSID_VideoInputDeviceCategory, $iNumberWebcam)     ;----------------------------------------------------------------------------------------------------     ;-----------------------------------  change resolution original video: --------------     Local $_GUID = "DWORD Data1;" &amp; _             "WORD  Data2;" &amp; _             "WORD  Data3;" &amp; _             "BYTE  Data4[8];" ;~  Local $tGuid = DllStructCreate($_GUID)      Local $_SIZE = "LONG cx;" &amp; _             "LONG cy;" ;~  Local $tSize = DllStructCreate($_SIZE)      Local $_VIDEO_STREAM_CONFIG_CAPS = $_GUID &amp; _             "ULONG    VideoStandard;" &amp; _             $_SIZE &amp; _             $_SIZE &amp; _             $_SIZE &amp; _             "int      CropGranularityX;" &amp; _             "int      CropGranularityY;" &amp; _             "int      CropAlignX;" &amp; _             "int      CropAlignY;" &amp; _             $_SIZE &amp; _             $_SIZE &amp; _             "int      OutputGranularityX;" &amp; _             "int      OutputGranularityY;" &amp; _             "int      StretchTapsX;" &amp; _             "int      StretchTapsY;" &amp; _             "int      ShrinkTapsX;" &amp; _             "int      ShrinkTapsY;" &amp; _             "int64  MinFrameInterval;" &amp; _             "int64   MaxFrameInterval;" &amp; _             "LONG     MinBitsPerSecond;" &amp; _             "LONG     MaxBitsPerSecond;"     Local $tVideoStream = DllStructCreate($_VIDEO_STREAM_CONFIG_CAPS)      Local $_AM_MEDIA = $_GUID &amp; _             $_GUID &amp; _             'BOOL  bFixedSizeSamples;' &amp; _             'BOOL  bTemporalCompression;' &amp; _             'ULONG    lSampleSize;' &amp; _             $_GUID &amp; _             'ptr pUnk;' &amp; _             'ULONG    cbFormat;' &amp; _             'ptr  pbFormat;'     Local $t_AM_MEDIA = DllStructCreate($_AM_MEDIA)      Local $_RECT = 'LONG left;' &amp; _             'LONG top;' &amp; _             'LONG right;' &amp; _             'LONG bottom;'     Local $_tagBITMAPINFOHEADER = 'DWORD biSize;' &amp; _             'LONG  biWidth;' &amp; _             'LONG  biHeight;' &amp; _             'WORD  biPlanes;' &amp; _             'WORD  biBitCount;' &amp; _             'DWORD biCompression;' &amp; _             'DWORD biSizeImage;' &amp; _             'LONG  biXPelsPerMeter;' &amp; _             'LONG  biYPelsPerMeter;' &amp; _             'DWORD biClrUsed;' &amp; _             'DWORD biClrImportant;'     Local $_tagVIDEOINFOHEADER = $_RECT &amp; _             $_RECT &amp; _             'DWORD            dwBitRate;' &amp; _             'DWORD            dwBitErrorRate;' &amp; _             'int64   AvgTimePerFrame;' &amp; _             $_tagBITMAPINFOHEADER  ;~  Local $MAX_PIN_NAME = 128     Local $_PinInfo = 'ptr   pFilter;' &amp; _             'int64    dir;' &amp; _             'wchar    achName[128];' ;~      'wchar    achName['&amp;$MAX_PIN_NAME&amp;'];'       Local $pConfig     $hr = $oBuild.FindInterface($PIN_CATEGORY_CAPTURE, $MEDIATYPE_Video, $oCapture[$iNumberWebcam], $sIID_IAMStreamConfig, $pConfig)     $oStreamConfig = ObjCreateInterface($pConfig, $sIID_IAMStreamConfig, $tagIAMStreamConfig)      Local $iCount = 0, $iSize = 0     $oStreamConfig.GetNumberOfCapabilities($iCount, $iSize)      ; Check the size to make sure we pass in the correct structure.     If DllStructGetSize($tVideoStream) == $iSize Then         For $iFormat = 0 To $iCount - 1 Step 1             Local $scc = DllStructGetPtr($tVideoStream)             Local $pmtConfig = DllStructGetPtr($t_AM_MEDIA)              $hr = $oStreamConfig.GetStreamCaps($iFormat, $pmtConfig, $scc) ;             Local $t_AM_MEDIA_TYPE = DllStructCreate($_AM_MEDIA, $pmtConfig)              Local $pbFormat = DllStructGetData($t_AM_MEDIA_TYPE, "pbFormat")             Local $t_VIDEOINFOHEADER = DllStructCreate($_tagVIDEOINFOHEADER, $pbFormat)              Local $videoWidth = DllStructGetData($t_VIDEOINFOHEADER, 'biWidth')             Local $videoHeight = DllStructGetData($t_VIDEOINFOHEADER, 'biHeight')             Local $bitCount = DllStructGetData($t_VIDEOINFOHEADER, 'biBitCount')             Local $dwBitRate = DllStructGetData($t_VIDEOINFOHEADER, 'dwBitRate')             Local $biCompression = DllStructGetData($t_VIDEOINFOHEADER, 'biCompression')             Local $biPlanes = DllStructGetData($t_VIDEOINFOHEADER, 'biPlanes')             Local $biSize = DllStructGetData($t_VIDEOINFOHEADER, 'biSizeImage')             Local $AvgframeRate = Round(10000000 / DllStructGetData($t_VIDEOINFOHEADER, 'AvgTimePerFrame'))              ; identify FOURCC compression:             Local $sText = ''             For $i = 7 To 0 Step -2                 If $biCompression &lt;> 0 Then $sText = $sText &amp; Chr(Dec(StringMid(Hex($biCompression, 8), $i, 2)))             Next ;~          if $videoWidth &lt;> 0 Then ConsoleWrite('----- iFormat:'&amp;$iFormat&amp; '  VIDEOINFOHEADER:'&amp;$videoWidth&amp;'x'&amp;$videoHeight&amp;','&amp;$bitCount &amp; ', FrameRate:' &amp;$AvgframeRate&amp;', bitRate(MBs):' &amp; Round($dwBitRate/8/1024/1024,1) &amp; ', Compression:' &amp; Hex($biCompression,8)&amp; '-' _ ;~              &amp; $sText &amp; ', biSize(bytes):'  &amp; $biSize  &amp; @CRLF)              Local $FrameRate = 30 ;GUICtrlRead($FrameInput)             DllStructSetData($t_VIDEOINFOHEADER, 'AvgTimePerFrame', 10000000 / $FrameRate)             If $videoWidth = $xVideo And $videoHeight = $yVideo And $bitCount = $ibpp Then                 $hr = $oStreamConfig.SetFormat(DllStructGetPtr($t_AM_MEDIA_TYPE)) ;                 ExitLoop             EndIf              ; if there is no match with the desired res, I create one personalized:             If $iFormat = $iCount - 1 Then                 DllStructSetData($t_VIDEOINFOHEADER, 'biWidth', $xVideo)                 DllStructSetData($t_VIDEOINFOHEADER, 'biHeight', $yVideo)                 DllStructSetData($t_VIDEOINFOHEADER, 'biBitCount', $ibpp)                 $hr = $oStreamConfig.SetFormat(DllStructGetPtr($t_AM_MEDIA_TYPE)) ;             EndIf         Next          $oStreamConfig = 0     EndIf ; end change resolution      ;----------------------------------------------------------------------------------------------------     ;------------------------------------------------------AUDIO preview: -------------------------------      If $iAudioMic &lt;> 0 Then         _WebcamDS_EnumerateDevices($sCLSID_AudioInputDeviceCategory, $iAudioMic)         $pConfig = ''         $hr = $oBuild.FindInterface($PIN_CATEGORY_CAPTURE, $MEDIATYPE_Audio, $oCaptureAudio, $sIID_IAMStreamConfig, $pConfig)         Global $oAStreamConfig = ObjCreateInterface($pConfig, $sIID_IAMStreamConfig, $tagIAMStreamConfig)     EndIf  ;~  if IsObj($oCaptureAudio) Then ;~          local $pEnum ;~          $hr = $oCaptureAudio.EnumPins($pEnum) ;~          $oEnum =ObjCreateInterface($pEnum, $sIID_IEnumPins, $tagIEnumPins)  ;~          Local $pPin,$pCompress,$pInfo,$oPin ;~          While $oEnum.Next(1, $pPin, 0) = $S_OK ;~              $oPin = ObjCreateInterface($pPin, $sIID_IPin, $tagIPin)  ;~              local $pPinInfo ;~              $hr = $oPin.QueryPinInfo($pPinInfo) ;~              Local $t_PinInfo = DLLStructCreate($_PinInfo, $pPinInfo) ;~              ConsoleWrite('--PinName:--'&amp; @error &amp;' struct:'&amp;DLLStructGetData($t_PinInfo, 3)  &amp;@CRLF)  ;~              Local $pAudioMixer, $oAudioMixer ;~              $oPin = 0 ;~              $i +=1 ;~              ConsoleWrite('---i:'&amp;$i&amp;' hr:'&amp;$hr&amp;@CRLF) ;~          WEnd ;~          $oEnum = 0 ;~          $oPin = 0 ;~  EndIf       ;---------------------------------------------------------------------------------------     ;-----------------------------------  VMR7 or VMR9 renderer   --------------------------     If $Vmr9 = 0 Then         ;  Build the preview part of the graph.         $hr = $oBuild.RenderStream($PIN_CATEGORY_PREVIEW, $MEDIATYPE_Video, $oCapture[$iNumberWebcam], 0, 0)         If IsObj($oCaptureAudio) Then $hr = $oBuild.RenderStream($PIN_CATEGORY_PREVIEW, $MEDIATYPE_Audio, $oCaptureAudio, 0, 0)     Else         $oVmr9 = ObjCreateInterface($sCLSID_VideoMixingRenderer9, $sIID_IBaseFilter, $tagIBaseFilter)          ; Call IFilterGraph::AddFilter on the Filter Graph Manager to add the VMR-9 to the filter graph:         $hr = $oGraph.AddFilter($oVmr9, "VMR9")          ; Call the ICaptureGraphBuilder2::RenderStream method to render the video stream to the VMR and eventually the audio:         $hr = $oBuild.RenderStream($PIN_CATEGORY_PREVIEW, $MEDIATYPE_Video, $oCapture[$iNumberWebcam], 0, $oVmr9)         If IsObj($oCaptureAudio) Then $hr = $oBuild.RenderStream($PIN_CATEGORY_PREVIEW, $MEDIATYPE_Audio, $oCaptureAudio, 0, 0)         ;       ConsoleWrite(">>RenderstreamPrev VMR9 hr = " &amp; Hex($hr) &amp; @CRLF)    ;>>RenderstreamPrev VMR9 hr = 0004027E  OK: Preview was rendered throught the Smart Tee filter,         $oVmr9 = 0     EndIf      ; set position e dimensions of webcam inside GUI, eventually rescale it     Local $iX = 0, $iY = 0 ; line of buttons above      Local $aClientSize = WinGetClientSize($hGuiWin)     If $iScale = 1 Then         $xVideo = $aClientSize[0]         $yVideo = $aClientSize[1]     EndIf      If $iZoomW &lt;> 0 Then         $hr = $oBasicVideo.SetSourcePosition($iZoomX, $iZoomY, $iZoomW, $iZoomH)     EndIf     ;$hr = $oVideoWindow.SetWindowPosition($iX, $iY, $xVideo, $yVideo)     $hr = $oVideoWindow.SetWindowPosition($aClientSize[0] - $xVideo, $iY, $xVideo, $yVideo)      ; connect video to GUI     $hr = $oVideoWindow.put_Owner($hGuiWin)      ; borderless     $oVideoWindow.put_WindowStyle(BitOR($WS_CHILD, $WS_CLIPCHILDREN))      ; start graph     $oMediaControl.Run()   EndFunc   ;==>_WebcamDS_RenderWebcam   ; #FUNCTION# ==================================================================================================================== ; ; Name...........: _WebcamDS_Init ; Description ...: Create Direct Show objects and enumerate webcams, compressors, micAudio ; Syntax.........: _WebcamDS_Init() ; Parameters ....: none ; Return values .: Success - it fills 3 array  $aWebcamList, $aCompressorList, $aMicList ;                  Failure - Returns 0 and Sets @Error: ;                  |0 - No error. ; Author ........: Frank10 ; Modified.......: ; Remarks .......: call it at the beginning of the script ; Related .......: ; Link ..........; ; Example .......; Yes ; ; =============================================================================================================================== Func _WebcamDS_Init()     Local $hr, $aCall ;~  / / Create the FGM.     $oGraph = ObjCreateInterface($sCLSID_FilterGraph, $sIID_IGraphBuilder, $tagIGraphBuilder)  ;~  / / Create the capture graph builder helper object     $oBuild = ObjCreateInterface($sCLSID_CaptureGraphBuilder2, $sIID_ICaptureGraphBuilder2, $tagICaptureGraphBuilder2)  ;~  / / Tell the capture graph builder about the FGM.     $oBuild.SetFiltergraph($oGraph)      Local $pMediaControl     $oGraph.QueryInterface($sIID_IMediaControl, $pMediaControl)     $oMediaControl = ObjCreateInterface($pMediaControl, $sIID_IMediaControl)      Local $pVideoWindow     $oGraph.QueryInterface($sIID_IVideoWindow, $pVideoWindow)     $oVideoWindow = ObjCreateInterface($pVideoWindow, $sIID_IVideoWindow, $tagIVideoWindow)      Local $pBasicVideo     $oGraph.QueryInterface($sIID_IBasicVideo, $pBasicVideo)     $oBasicVideo = ObjCreateInterface($pBasicVideo, $sIID_IBasicVideo, $tagIBasicVideo)      If $aWebcamList[1] = '' Then         _WebcamDS_EnumerateDevices($sCLSID_VideoInputDeviceCategory)          _WebcamDS_EnumerateDevices($sCLSID_VideoCompressorCategory)          _WebcamDS_EnumerateDevices($sCLSID_AudioInputDeviceCategory)     EndIf EndFunc   ;==>_WebcamDS_Init
